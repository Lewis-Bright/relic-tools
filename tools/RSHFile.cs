// This file is a part of the Relic Tools and is copyright 2006-2018 IBBoard.
//
// The file and the library/program it is in are licensed under the GNU GPL license, either version 3 of the License or (at your option) any later version. Please see COPYING for more information and the full license.
using System;
using System.IO;
using IBBoard.Relic.RelicTools.Exceptions;
using IBBoard.Relic.RelicTools.Collections;

namespace IBBoard.Relic.RelicTools
{
	/// <summary>
	/// Summary description for WTPFile.
	/// </summary>
	public class RSHFile:RelicChunkyFile
	{
		public enum ShaderLayers {None=1, SpecMap=2, SelfIllum=4, Opacity = 8}

		public RSHFile(string filename, ChunkyStructureCollection col): base(filename, col){}

		public RSHFile(string filename, ChunkyFolder folder): base(filename, folder){}
		
		public RSHFile(string filename, ChunkyCollection col): base(filename, col){}

		public ChunkyFolder GetBaseImageFolder()
		{
			return (ChunkyFolder)((ChunkyFolder)this.ChunkyStructures[0].RootChunks[0]).Children[0];
		}

		public ChunkyDataCHAN GetBaseImageDataCHAN()
		{
			return (ChunkyDataCHAN)GetSHDRFolder().Children[1];
		}

		public ChunkyFolder GetSHDRFolder()
		{
			ChunkyCollection col = ((ChunkyFolder)this.ChunkyStructures[0].RootChunks[0]).Children;
			return (ChunkyFolder)col[col.Count-1];
		}

		public void SaveParts(DirectoryInfo destination)
		{
			string filenamebase = filename.Substring(0, filename.LastIndexOf('.'));

			saveFolder((ChunkyFolder)this.ChunkyStructures[0].RootChunks[0], destination, filenamebase);
		}

		private void saveFolder(ChunkyFolder folder, DirectoryInfo destination, string filenamebase)
		{
			int children = folder.Children.Count;
			ChunkyChunk chunk = null;

			for (int i = 0; i<children; i++)
			{
				chunk = folder.Children[i];

				if (chunk is ChunkyFolder)
				{
					this.saveFolder((ChunkyFolder)chunk, destination, filenamebase);
				}
				else if (chunk is ChunkyDataDATAIMAG)
				{
					((ChunkyDataDATAIMAG)chunk).Save(destination, folder.Parent.Name.Substring(folder.Parent.Name.LastIndexOf('/')+1));
				}
			}
		}

		public static RSHFile Create(string filepath)
		{
			return Create(new string[]{filepath, "", "", "", "", ""}, filepath);
		}

		public static RSHFile Create(string[] filepaths, string mainfilepath)
		{
			if (filepaths.Length!=6)
			{
				throw new InvalidOperationException("RSH file must contain six file path entries");
			}

			string baseFileName = mainfilepath.Substring(mainfilepath.LastIndexOf(Path.DirectorySeparatorChar)+1);
			string baseFileNameLower = baseFileName.ToLower();

			string directory = "";

			if (mainfilepath.IndexOf(Path.DirectorySeparatorChar)!=-1)
			{
				directory = mainfilepath.Substring(0, mainfilepath.LastIndexOf(Path.DirectorySeparatorChar))+Path.DirectorySeparatorChar;
			}
			
			if(baseFileNameLower.EndsWith(".dds"))
			{
				baseFileName = baseFileName.Substring(0, baseFileName.Length-4);
			}
			else
			{
				throw new InvalidFileException("File specified cannot be converted to a RSH file");
			}

			string texturePath = "";
			
			DirectoryInfo dir = new DirectoryInfo(directory);
			
			while(dir.Parent!=null)
			{
				texturePath = dir.Name+"/"+texturePath;

				if (dir.Name.ToLower()!="art")
				{
					dir = dir.Parent;
				}
				else
				{
					break;
				}
			}

			if (dir.Parent==null)
			{
				throw new InvalidFileException("RSH Files must be built within the 'data\\art' path to ensure correct WTP loading");
			}

			ChunkyDataDATA defaultData = null;
			ChunkyData attr = null;
			byte [] data;

			int width = 0;
			int height = 0;
			int mipmaps = 0;
			int size = 0;
			byte type;
			byte byte1;
			FileInfo file;
			BinaryReader br;
			ChunkyFolder defaultFolder;
			ChunkyData head;
			ChunkyFolder txtr;
			string filename;
			string mainTexturePath = texturePath+baseFileName;
			string[] texturePaths = new string[filepaths.Length];

			int layers = 0;

			if (filepaths[1]!="" && filepaths[1]!=null && filepaths[2]!="" && filepaths[2]!=null)
			{
				layers = (int)ShaderLayers.SpecMap;
			}
			
			if (filepaths[3]!="" && filepaths[3]!=null)
			{
				layers+= (int)ShaderLayers.SelfIllum;
			}

			if (filepaths[4]!="" && filepaths[4]!=null)
			{
				layers+= (int)ShaderLayers.Opacity;
			}

			ChunkyFolder shrf = new ChunkyFolder("SHRF", 1, mainTexturePath);

			CompilationEvent("Compiling RSH Texture...");

			for (int i = 0; i<filepaths.Length; i++)
			{
				if (filepaths[i]=="" || filepaths[i]==null)
				{
					continue;
				}

				filename = filepaths[i].Substring(filepaths[i].LastIndexOf(Path.DirectorySeparatorChar)+1);
				filename = filename.Substring(0, filename.Length-4);

				if (File.Exists(filepaths[i]))
				{
					CompilationEvent("Reading "+filename+".dds");
					file = new FileInfo(directory+filename+".dds");
					br = new BinaryReader(file.OpenRead());
					br.BaseStream.Seek(0, SeekOrigin.Begin);
					data = br.ReadBytes((int)file.Length);

					defaultData = ChunkyDataDATAIMAG.CreateFromDDS(2, "", data);
				
					br.BaseStream.Seek(12,SeekOrigin.Begin);
					height = br.ReadInt32();
					width = br.ReadInt32();
					size = br.ReadInt32();
					br.BaseStream.Seek(4, SeekOrigin.Current);
					mipmaps = br.ReadInt32();
					br.BaseStream.Seek(87, SeekOrigin.Begin);
					type = br.ReadByte();
					br.Close();

					if ((char)type=='1')
					{
						type = 0x8;
						byte1 = 0x5;
					}
                    else if ((char)type == '3')
                    {
                        type = 0xA;
                        byte1 = 0x6;
                    }
                    else if ((char)type == '5')
                    {
                        type = 0xB;
                        byte1 = 0x7;
                    }
                    else
                    {
                        throw new RelicTools.Exceptions.FileNotFoundException("RSH files must be made from DXT1, DXT3 or DXT5 DDS files");
                    }

					data = new byte[]{type, 0x0, 0x0, 0x0, (byte)width, (byte)(width>>8), (byte)(width>>16), (byte)(width>>24), (byte)(height), (byte)(height>>8), (byte)(height>>16), (byte)(height>>24), (byte)mipmaps, (byte)(mipmaps>>8), (byte)(mipmaps>>16), (byte)(mipmaps>>24)};
					attr = new ChunkyDataUnknown("ATTR", 2, "", data);
				}
				else
				{
					throw new RelicTools.Exceptions.FileNotFoundException("RSH files must be made from a DDS file");
				}

				defaultFolder = new ChunkyFolder("IMAG", 1, "");

				defaultFolder.Children.Add(attr);
				defaultFolder.Children.Add(defaultData);

				head = new ChunkyDataUnknown("HEAD", 1, "", new byte[]{byte1, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00});

				texturePaths[i] = texturePath+filename;
				txtr = new ChunkyFolder("TXTR", 1, texturePath+filename);
				txtr.Children.Add(head);
				txtr.Children.Add(defaultFolder);
				shrf.Children.Add(txtr);
			}

			CompilationEvent("Compiling Texture Shaders");

			ChunkyDataINFO info = new ChunkyDataINFOGeneric(1, "", new byte[]{0x06, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, (byte)((layers<=1)?0xcc:0xcd), 0xcc, 0xcc, 0x3d, 0x01, 0x00, 0x00, 0x00, 0x00 });

			data = new byte[156+mainTexturePath.Length];
			data[0] = 0x00;
			data[1] = 0x00;
			data[2] = 0x00;
			data[3] = 0x00;
			data[4] = 0x01;
			data[5] = 0x00;
			data[6] = 0x00;
			data[7] = 0x00;

			if (layers<=1)
			{
				data[8] = 0x96;
				data[9] = 0x96;
				data[10] = 0x96;
				data[11] = 0xff;
			}
			else
			{
				data[8] = 0x0;
				data[9] = 0x0;
				data[10] = 0x0;
				data[11] = 0xff;
			}

			data[12] = (byte)mainTexturePath.Length;
			data[13] = (byte)(mainTexturePath.Length>>8);
			data[14] = (byte)(mainTexturePath.Length>>16);
			data[15] = (byte)(mainTexturePath.Length>>24);

			System.Text.ASCIIEncoding.ASCII.GetBytes(mainTexturePath).CopyTo(data, 16);
			byte[] temp = new byte[]{0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f};
			temp.CopyTo(data, 16+mainTexturePath.Length);
			
			ChunkyData chan0 = new ChunkyDataUnknown("CHAN", 3, "", data);

			ChunkyData chan1, chan2, chan3, chan4, chan5;
			
			//fill out the defaults
			if ((layers & (int)ShaderLayers.SpecMap)!=(int)ShaderLayers.SpecMap)
			{
				//they're not using a spec map
				data = new byte[]{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, (byte)((layers<=1)?0xe5:0x00), (byte)((layers<=1)?0xe5:0x00), (byte)((layers<=1)?0xe5:0x00), 0xff, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f};
				chan1 = new ChunkyDataUnknown("CHAN", 3, "", data);

				data = new byte[]{0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f};
				chan2 = new ChunkyDataUnknown("CHAN", 3, "", data);
			}
			else
			{
				//they are using a spec map				
				data = new byte[156+texturePaths[1].Length];
				data[0] = 0x01;//ID
				data[1] = 0x00;
				data[2] = 0x00;
				data[3] = 0x00;
				data[4] = 0x01;//format - 1 = Texture, 2 = Add, 3 = Blend, 4+ = blank
				data[5] = 0x00;
				data[6] = 0x00;
				data[7] = 0x00;
				data[8] = 0x00;
				data[9] = 0x00;
				data[10] = 0x00;
				data[11] = 0xff;
				data[12] = (byte)texturePaths[1].Length;
				data[13] = (byte)(texturePaths[1].Length>>8);
				data[14] = (byte)(texturePaths[1].Length>>16);
				data[15] = (byte)(texturePaths[1].Length>>24);

				System.Text.ASCIIEncoding.ASCII.GetBytes(texturePaths[1]).CopyTo(data, 16);
				temp = new byte[]{0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f};
				temp.CopyTo(data, 16+texturePaths[1].Length);
				chan1 = new ChunkyDataUnknown("CHAN", 3, "", data);

				data = new byte[156+texturePaths[2].Length];
				data[0] = 0x02;
				data[1] = 0x00;
				data[2] = 0x00;
				data[3] = 0x00;
				data[4] = 0x01;
				data[5] = 0x00;
				data[6] = 0x00;
				data[7] = 0x00;
				data[8] = 0x00;
				data[9] = 0x00;
				data[10] = 0x00;
				data[11] = 0xff;
				data[12] = (byte)texturePaths[2].Length;
				data[13] = (byte)(texturePaths[2].Length>>8);
				data[14] = (byte)(texturePaths[2].Length>>16);
				data[15] = (byte)(texturePaths[2].Length>>24);

				System.Text.ASCIIEncoding.ASCII.GetBytes(texturePaths[2]).CopyTo(data, 16);
				temp = new byte[]{0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f};
				temp.CopyTo(data, 16+texturePaths[2].Length);
				chan2 = new ChunkyDataUnknown("CHAN", 3, "", data);
			}
			

			if ((layers & (int)ShaderLayers.SelfIllum)!=(int)ShaderLayers.SelfIllum)
			{
				data = new byte[]{0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f};
			}
			else
			{
				data = new byte[156+texturePaths[3].Length];
				data[0] = 0x03;
				data[1] = 0x00;
				data[2] = 0x00;
				data[3] = 0x00;
				data[4] = 0x01;
				data[5] = 0x00;
				data[6] = 0x00;
				data[7] = 0x00;
				data[8] = 0x00;
				data[9] = 0x00;
				data[10] = 0x00;
				data[11] = 0xff;
				data[12] = (byte)texturePaths[3].Length;
				data[13] = (byte)(texturePaths[3].Length>>8);
				data[14] = (byte)(texturePaths[3].Length>>16);
				data[15] = (byte)(texturePaths[3].Length>>24);

				System.Text.ASCIIEncoding.ASCII.GetBytes(texturePaths[3]).CopyTo(data, 16);
				temp = new byte[]{0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f};
				temp.CopyTo(data, 16+texturePaths[3].Length);
			}
			chan3 = new ChunkyDataUnknown("CHAN", 3, "", data);

			if ((layers & (int)ShaderLayers.Opacity)!=(int)ShaderLayers.Opacity)
			{
				data = new byte[]{0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f};
			}
			else
			{
				data = new byte[156+texturePaths[4].Length];
				data[0] = 0x04;
				data[1] = 0x00;
				data[2] = 0x00;
				data[3] = 0x00;
				data[4] = 0x01;
				data[5] = 0x00;
				data[6] = 0x00;
				data[7] = 0x00;
				data[8] = 0x00;//0x00;
				data[9] = 0x00;//0x00;
				data[10] = 0x00;//0x00;
				data[11] = 0xff;
				data[12] = (byte)texturePaths[4].Length;
				data[13] = (byte)(texturePaths[4].Length>>8);
				data[14] = (byte)(texturePaths[4].Length>>16);
				data[15] = (byte)(texturePaths[4].Length>>24);

				System.Text.ASCIIEncoding.ASCII.GetBytes(texturePaths[4]).CopyTo(data, 16);
				temp = new byte[]{0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f};
				temp.CopyTo(data, 16+texturePaths[4].Length);
			}
			chan4 = new ChunkyDataUnknown("CHAN", 3, "", data);

			//if (filepaths.Length<6)
			//{
				data = new byte[]{0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
									 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f};
			/*}
			else
			{
				data = new byte[156+texturePaths[1].Length];
				data[0] = 0x05;
				data[1] = 0x00;
				data[2] = 0x00;
				data[3] = 0x00;
				data[4] = 0x01;
				data[5] = 0x00;
				data[6] = 0x00;
				data[7] = 0x00;
				data[8] = 0x00;
				data[9] = 0x00;
				data[10] = 0x00;
				data[11] = 0xff;
				data[12] = (byte)texturePaths[1].Length;
				data[13] = (byte)(texturePaths[1].Length>>8);
				data[14] = (byte)(texturePaths[1].Length>>16);
				data[15] = (byte)(texturePaths[1].Length>>24);

				System.Text.ASCIIEncoding.ASCII.GetBytes(texturePaths[1]).CopyTo(data, 16);
				temp = new byte[]{0x05, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x3f};
				temp.CopyTo(data, 16+texturePaths[1].Length);
			}*/
			chan5 = new ChunkyDataUnknown("CHAN", 3, "", data);
			

			ChunkyFolder shdr = new ChunkyFolder("SHDR", 1, mainTexturePath);
			shdr.Children.Add(info);
			shdr.Children.Add(chan0);
			shdr.Children.Add(chan1);
			shdr.Children.Add(chan2);
			shdr.Children.Add(chan3);
			shdr.Children.Add(chan4);
			shdr.Children.Add(chan5);


			CompilationEvent("Compiling RSH File");

			shrf.Children.Add(shdr);

			return new RSHFile(baseFileName+".rsh", shrf);//new ChunkyStructureCollection(new RelicChunkyStructure(
			
			//RelicChunkyFile.SaveChunky(directory+baseFileName+".rsh", shrf.GetBytes());
		}
	}
}